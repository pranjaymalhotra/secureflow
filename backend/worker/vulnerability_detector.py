import json
import logging
import re
from typing import List, Dict, Any, Optional, Set, Tuple
from pathlib import Path
import ast

from ..gateway.models import VulnerabilityFinding, SeverityLevel
from .llm_client import load_model_config


logger = logging.getLogger(__name__)

MODEL_CONFIG = load_model_config()
DEFAULT_MODEL = MODEL_CONFIG.get("primary_model", "deepseek-coder-v2:16b")

class VulnerabilityDetector:
    """Professional LLM-based vulnerability detection with comprehensive coverage."""
    
    def __init__(self, llm_client=None):
        self.llm_client = llm_client
        self.vulnerability_patterns = self._load_comprehensive_patterns()
        self.model_config = MODEL_CONFIG
        self.file_type_handlers = {
            '.py': self._analyze_python_file,
            '.js': self._analyze_javascript_file,
            '.ts': self._analyze_typescript_file,
            '.java': self._analyze_java_file,
            '.php': self._analyze_php_file,
            '.c': self._analyze_c_file,
            '.cpp': self._analyze_cpp_file,
            '.go': self._analyze_go_file,
            '.rs': self._analyze_rust_file,
            '.rb': self._analyze_ruby_file,
            '.cs': self._analyze_csharp_file,
            '.swift': self._analyze_swift_file,
            '.kt': self._analyze_kotlin_file,
        }
        self.non_code_files = {'.json', '.yaml', '.yml', '.md', '.txt', '.xml', '.csv', '.ini', '.cfg', '.conf'}
        # Lower confidence threshold to catch more issues
        self.min_confidence_threshold = 0.3
        self.high_confidence_threshold = 0.7
    
    def _load_comprehensive_patterns(self) -> Dict[str, Any]:
        """Load comprehensive vulnerability patterns covering all OWASP Top 10 and more."""
        return {
            # A01:2021 - Broken Access Control
            "broken_access_control": {
                "patterns": [
                    {
                        "regex": r"@app\.route\s*\([^)]*\)\s*\n\s*def\s+(\w+)",
                        "post_check": self._check_missing_auth_decorator,
                        "description": "Route without authentication"
                    },
                    {
                        "regex": r"(?:admin|delete|update|modify|create)(?:_|\s)?(?:user|data|config)",
                        "context_required": ["function", "route", "method"],
                        "description": "Administrative function without access control"
                    }
                ],
                "severity": "critical",
                "owasp": "A01:2021",
                "cwe": ["CWE-284", "CWE-285", "CWE-862"]
            },
            
            # A02:2021 - Cryptographic Failures
            "weak_crypto": {
                "patterns": [
                    {
                        "regex": r"\b(?:md5|sha1)\s*\([^)]*(?:password|secret|key)",
                        "description": "Weak hash algorithm for passwords"
                    },
                    {
                        "regex": r"\b(?:DES|RC4|ECB)\s*[(\.]",
                        "description": "Weak encryption algorithm"
                    },
                    {
                        "regex": r"(?:Math\.random|random\.random)\s*\(\s*\).*(?:token|session|key)",
                        "description": "Insecure random number for security"
                    }
                ],
                "severity": "high",
                "owasp": "A02:2021",
                "cwe": ["CWE-327", "CWE-328", "CWE-330"]
            },
            
            # A03:2021 - Injection
            "sql_injection": {
                "patterns": [
                    {
                        "regex": r"(?:execute|query|cursor\.execute)\s*\([^)]*['\"].*?['\"].*?(?:\+|%|\$|f['\"]|\.format)",
                        "description": "SQL query with string concatenation"
                    },
                    {
                        "regex": r"(?:SELECT|INSERT|UPDATE|DELETE).*(?:\+|%|f['\"]|`\$\{)",
                        "description": "Direct SQL construction"
                    }
                ],
                "severity": "critical",
                "owasp": "A03:2021",
                "cwe": ["CWE-89"]
            },
            
            "command_injection": {
                "patterns": [
                    {
                        "regex": r"(?:os\.system|subprocess\.|exec|eval|shell_exec)\s*\([^)]*(?:\+|%|f['\"]|\$)",
                        "description": "Command execution with user input"
                    },
                    {
                        "regex": r"(?:spawn|exec)\s*\([^)]*(?:req\.|request|params|body)",
                        "description": "Process spawn with user data"
                    }
                ],
                "severity": "critical",
                "owasp": "A03:2021",
                "cwe": ["CWE-78"]
            },
            
            "code_injection": {
                "patterns": [
                    {
                        "regex": r"\beval\s*\([^)]*(?:request|req\.|params|input|user)",
                        "description": "Eval with user input"
                    },
                    {
                        "regex": r"new\s+Function\s*\([^)]*(?:request|input|user)",
                        "description": "Dynamic function creation"
                    }
                ],
                "severity": "critical",
                "owasp": "A03:2021",
                "cwe": ["CWE-94", "CWE-95"]
            },
            
            "xss": {
                "patterns": [
                    {
                        "regex": r"(?:innerHTML|outerHTML|document\.write)\s*[=\+]+\s*[^;]*(?:request|input|param|query)",
                        "description": "DOM XSS vulnerability"
                    },
                    {
                        "regex": r"(?:res\.send|res\.write|echo|print)\s*\([^)]*(?:request|req\.|params|query)(?!.*(?:escape|sanitize))",
                        "description": "Reflected XSS"
                    }
                ],
                "severity": "high",
                "owasp": "A03:2021",
                "cwe": ["CWE-79"]
            },
            
            # A04:2021 - Insecure Design
            "insecure_design": {
                "patterns": [
                    {
                        "regex": r"(?:rate[_-]?limit|throttle).*?(\d+).*?(?:second|minute)",
                        "post_check": self._check_weak_rate_limit,
                        "description": "Weak rate limiting"
                    },
                    {
                        "regex": r"(?:password|pwd).*?(?:length|min|max).*?[<>=]\s*(\d+)",
                        "post_check": self._check_weak_password_policy,
                        "description": "Weak password requirements"
                    }
                ],
                "severity": "medium",
                "owasp": "A04:2021",
                "cwe": ["CWE-307", "CWE-521"]
            },
            
            # A05:2021 - Security Misconfiguration
            "security_misconfiguration": {
                "patterns": [
                    {
                        "regex": r"(?:debug|DEBUG)\s*[:=]\s*(?:True|true|1|'true'|\"true\")",
                        "description": "Debug mode enabled"
                    },
                    {
                        "regex": r"(?:cors|CORS).*?(?:origin|Origin)\s*[:=]\s*['\"]?\*['\"]?",
                        "description": "Overly permissive CORS"
                    },
                    {
                        "regex": r"app\.run\s*\([^)]*debug\s*=\s*True",
                        "description": "Flask debug mode in production"
                    }
                ],
                "severity": "high",
                "owasp": "A05:2021",
                "cwe": ["CWE-16", "CWE-732"]
            },
            
            # A06:2021 - Vulnerable and Outdated Components
            "vulnerable_components": {
                "patterns": [
                    {
                        "regex": r"(?:require|import).*?['\"]([^'\"]+)['\"].*?['\"]([0-9]+\.[0-9]+\.[0-9]+)['\"]",
                        "post_check": self._check_vulnerable_version,
                        "description": "Potentially vulnerable dependency"
                    }
                ],
                "severity": "medium",
                "owasp": "A06:2021",
                "cwe": ["CWE-1104"]
            },
            
            # A07:2021 - Identification and Authentication Failures
            "auth_failures": {
                "patterns": [
                    {
                        "regex": r"(?:password|passwd|pwd)\s*(?:==|===|!=)\s*['\"]",
                        "description": "Hardcoded password comparison"
                    },
                    {
                        "regex": r"(?:session|token).*?(?:timeout|expire).*?(\d+)",
                        "post_check": self._check_weak_session_timeout,
                        "description": "Weak session management"
                    }
                ],
                "severity": "high",
                "owasp": "A07:2021",
                "cwe": ["CWE-287", "CWE-798"]
            },
            
            # A08:2021 - Software and Data Integrity Failures
            "unsafe_deserialization": {
                "patterns": [
                    {
                        "regex": r"pickle\.loads?\s*\([^)]*(?:request|data|input)",
                        "description": "Unsafe pickle deserialization"
                    },
                    {
                        "regex": r"yaml\.load\s*\([^)]*(?!Loader\s*=\s*yaml\.SafeLoader)",
                        "description": "Unsafe YAML loading"
                    }
                ],
                "severity": "critical",
                "owasp": "A08:2021",
                "cwe": ["CWE-502"]
            },
            
            # A09:2021 - Security Logging and Monitoring Failures
            "insufficient_logging": {
                "patterns": [
                    {
                        "regex": r"(?:login|auth|authenticate).*\n(?!.*(?:log|audit|monitor))",
                        "description": "Authentication without logging"
                    },
                    {
                        "regex": r"(?:catch|except)\s*(?:\(|\s).*?\{?\s*(?:pass|continue|return)\s*\}?",
                        "description": "Silent error handling"
                    }
                ],
                "severity": "low",
                "owasp": "A09:2021",
                "cwe": ["CWE-778", "CWE-223"]
            },
            
            # A10:2021 - Server-Side Request Forgery (SSRF)
            "ssrf": {
                "patterns": [
                    {
                        "regex": r"(?:requests\.get|fetch|urllib|httpClient)\s*\([^)]*(?:request|params|user)",
                        "description": "SSRF vulnerability"
                    }
                ],
                "severity": "high",
                "owasp": "A10:2021",
                "cwe": ["CWE-918"]
            },
            
            # Additional important vulnerabilities
            "path_traversal": {
                "patterns": [
                    {
                        "regex": r"(?:open|file|read)\s*\([^)]*(?:\+|f['\"]|%).*(?:request|input|param)",
                        "description": "Path traversal vulnerability"
                    }
                ],
                "severity": "high",
                "owasp": "A01:2021",
                "cwe": ["CWE-22"]
            },
            
            "hardcoded_secrets": {
                "patterns": [
                    {
                        "regex": r"(?:password|secret|api[_-]?key|token|private[_-]?key)\s*[:=]\s*['\"][^'\"]{8,}['\"]",
                        "post_check": self._validate_real_secret,
                        "description": "Hardcoded credentials"
                    }
                ],
                "severity": "critical",
                "owasp": "A07:2021",
                "cwe": ["CWE-798", "CWE-259"]
            },
            
            "xxe": {
                "patterns": [
                    {
                        "regex": r"(?:XMLParser|etree\.parse|parseXML).*?resolve_entities\s*=\s*True",
                        "description": "XML External Entity (XXE) vulnerability"
                    }
                ],
                "severity": "high",
                "owasp": "A05:2021",
                "cwe": ["CWE-611"]
            },
            
            "race_condition": {
                "patterns": [
                    {
                        "regex": r"(?:global|shared).*?(?:resource|state|counter)(?!.*(?:lock|mutex|synchronized))",
                        "description": "Potential race condition"
                    }
                ],
                "severity": "medium",
                "owasp": "A04:2021",
                "cwe": ["CWE-362"]
            },
            
            "information_disclosure": {
                "patterns": [
                    {
                        "regex": r"(?:console\.log|print|logger\.|System\.out).*?(?:password|secret|key|token)",
                        "description": "Sensitive data in logs"
                    },
                    {
                        "regex": r"(?:error|exception).*?(?:stack|trace|details)",
                        "description": "Detailed error messages"
                    }
                ],
                "severity": "medium",
                "owasp": "A01:2021",
                "cwe": ["CWE-209", "CWE-532"]
            },
            
            "insecure_file_upload": {
                "patterns": [
                    {
                        "regex": r"(?:upload|save).*?file(?!.*(?:validate|check|verify|allowed))",
                        "description": "File upload without validation"
                    }
                ],
                "severity": "high",
                "owasp": "A03:2021",
                "cwe": ["CWE-434"]
            }
        }
    
    def analyze_file(
        self, 
        file_path: Path, 
        content: str, 
        file_info: Dict[str, Any]
    ) -> List[VulnerabilityFinding]:
        """Comprehensive file analysis with multiple detection methods."""
        all_findings = []
        
        try:
            # Skip non-code files for code-specific vulnerabilities
            file_ext = file_path.suffix.lower()
            
            # 1. Pattern-based detection (catches most common patterns)
            pattern_findings = self._comprehensive_pattern_detection(file_path, content, file_info)
            all_findings.extend(pattern_findings)
            
            # 2. Language-specific analysis
            if file_ext in self.file_type_handlers:
                language_findings = self.file_type_handlers[file_ext](file_path, content, file_info)
                all_findings.extend(language_findings)
            
            # 3. AST-based analysis for supported languages
            if file_ext in ['.py', '.js', '.ts']:
                ast_findings = self._ast_based_analysis(file_path, content, file_info)
                all_findings.extend(ast_findings)
            
            # 4. Enhanced LLM analysis (catches complex/contextual issues)
            if self.llm_client:
                llm_findings = self._comprehensive_llm_analysis(file_path, content, file_info)
                all_findings.extend(llm_findings)
            
            # 5. Configuration file analysis
            if file_ext in self.non_code_files:
                config_findings = self._analyze_configuration_file(file_path, content, file_info)
                all_findings.extend(config_findings)
            
            # 6. Cross-file dependency analysis
            dependency_findings = self._analyze_dependencies(file_path, content, file_info)
            all_findings.extend(dependency_findings)
            
            # Deduplicate findings while keeping all unique ones
            deduplicated = self._smart_deduplication(all_findings)
            
            # Sort by severity and confidence
            deduplicated.sort(key=lambda f: (
                ['critical', 'high', 'medium', 'low', 'info'].index(f.severity.value),
                -f.confidence
            ))
            
            logger.info(f"Found {len(deduplicated)} vulnerabilities in {file_path}")
            return deduplicated
            
        except Exception as e:
            logger.error(f"Error analyzing file {file_path}: {e}")
            return []
    
    def _comprehensive_pattern_detection(
        self, 
        file_path: Path, 
        content: str, 
        file_info: Dict[str, Any]
    ) -> List[VulnerabilityFinding]:
        """Comprehensive pattern-based detection."""
        findings = []
        lines = content.split('\n')
        
        for vuln_type, config in self.vulnerability_patterns.items():
            for pattern_config in config["patterns"]:
                pattern = pattern_config.get("regex")
                if not pattern:
                    continue
                
                for line_num, line in enumerate(lines, 1):
                    matches = list(re.finditer(pattern, line, re.IGNORECASE))
                    for match in matches:
                        # Post-check validation if defined
                        if "post_check" in pattern_config:
                            check_func = pattern_config["post_check"]
                            if not check_func(line, match, lines, line_num):
                                continue
                        
                        # Context validation
                        if not self._validate_context(line, lines, line_num, pattern_config, file_path):
                            continue
                        
                        confidence = self._calculate_pattern_confidence(
                            line, lines, line_num, vuln_type, pattern_config
                        )
                        
                        if confidence >= self.min_confidence_threshold:
                            finding = VulnerabilityFinding(
                                worker=self.llm_client.model_name if self.llm_client else "pattern_detector",
                                file=str(file_path),
                                line=line_num,
                                category=vuln_type,
                                severity=SeverityLevel(config["severity"]),
                                confidence=confidence,
                                explanation=f"{pattern_config.get('description', config.get('description', ''))} - Pattern match: {pattern}",
                                code_snippet=self._extract_code_snippet(content, line_num),
                                references=self._get_references(config)
                            )
                            findings.append(finding)
        
        return findings
    
    def _comprehensive_llm_analysis(
        self, 
        file_path: Path, 
        content: str, 
        file_info: Dict[str, Any]
    ) -> List[VulnerabilityFinding]:
        """Comprehensive LLM analysis with all vulnerability types."""
        try:
            prompt = self._create_comprehensive_llm_prompt(file_path, content, file_info)
            
            # Use lower temperature for more consistent results
            response = self.llm_client.generate_sync(prompt, temperature=0.2)
            
            # Parse findings with relaxed validation
            findings = self._parse_comprehensive_llm_response(response, file_path, content)
            
            return findings
            
        except Exception as e:
            logger.error(f"Comprehensive LLM analysis failed for {file_path}: {e}")
            return []
    
    def _create_comprehensive_llm_prompt(
        self, 
        file_path: Path, 
        content: str, 
        file_info: Dict[str, Any]
    ) -> str:
        """Create comprehensive prompt covering all vulnerability types."""
        language = file_info.get("language", "unknown")
        
        prompt = f"""You are a professional security auditor. Analyze this {language} code for ALL security vulnerabilities.

File: {file_path}
Language: {language}

IMPORTANT: Report ALL potential security issues, even with lower confidence. It's better to flag potential issues than miss real vulnerabilities.

Check for ALL of these vulnerability types:

1. **Injection Flaws** (CRITICAL):
   - SQL Injection: String concatenation in queries, dynamic SQL
   - Command Injection: os.system(), subprocess, exec with user input
   - Code Injection: eval(), exec() with user data
   - LDAP/XML/XPath/Template injection

2. **Broken Authentication/Access Control** (CRITICAL):
   - Missing authentication on sensitive functions
   - Hardcoded credentials
   - Weak password storage (MD5, SHA1, plaintext)
   - Missing authorization checks
   - Insecure session management

3. **Data Exposure** (HIGH):
   - Sensitive data in logs/errors
   - Hardcoded API keys/secrets
   - Information disclosure
   - Unencrypted sensitive data

4. **Security Misconfiguration** (HIGH):
   - Debug mode enabled
   - Default credentials
   - Overly permissive CORS
   - Missing security headers

5. **Vulnerable Components** (MEDIUM):
   - Outdated dependencies
   - Known vulnerable libraries

6. **Insufficient Logging** (LOW):
   - Missing security event logging
   - Silent error handling

7. **Other Critical Issues**:
   - Path Traversal
   - XXE (XML External Entities)
   - SSRF (Server-Side Request Forgery)
   - Race Conditions
   - Unsafe Deserialization (pickle, yaml.load)
   - Weak Cryptography
   - Insecure Random Numbers
   - File Upload vulnerabilities

Code to analyze:
```{language}
{content}
```

Return ALL findings (even low confidence ones) in this JSON format:
[
  {{
    "line": <line_number>,
    "category": "<vulnerability_type>",
    "severity": "<critical|high|medium|low>",
    "confidence": <0.3-1.0>,  // Include low confidence findings
    "explanation": "Detailed explanation",
    "evidence": "Code snippet showing the issue",
    "cwe": "CWE-XXX",
    "owasp": "AXX:2021"
  }}
]

Remember: Report EVERYTHING suspicious. Users can filter later."""

        return prompt
    
    def _parse_comprehensive_llm_response(
        self, 
        response: str, 
        file_path: Path, 
        content: str
    ) -> List[VulnerabilityFinding]:
        """Parse LLM response with relaxed validation."""
        findings = []
        
        try:
            # Extract JSON
            import re
            json_match = re.search(r'```json\s*(.*?)\s*```', response, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
            else:
                json_match = re.search(r'\[.*\]', response, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                else:
                    return []
            
            vulnerabilities = json.loads(json_str)
            
            for vuln in vulnerabilities:
                try:
                    # Accept lower confidence findings
                    confidence = float(vuln.get("confidence", 0.5))
                    if confidence < 0.3:  # Very low threshold
                        continue
                    
                    finding = VulnerabilityFinding(
                        worker=self.llm_client.model_name,
                        file=str(file_path),
                        line=vuln.get("line", 1),
                        category=vuln.get("category", "unknown"),
                        severity=SeverityLevel(vuln.get("severity", "medium")),
                        confidence=confidence,
                        explanation=vuln.get("explanation", ""),
                        code_snippet=vuln.get("evidence", self._extract_code_snippet(content, vuln.get("line", 1))),
                        references=[
                            f"https://cwe.mitre.org/data/definitions/{vuln.get('cwe', '').replace('CWE-', '')}.html" if vuln.get('cwe') else "",
                            f"https://owasp.org/www-project-top-ten/2021/{vuln.get('owasp', '')}" if vuln.get('owasp') else ""
                        ]
                    )
                    findings.append(finding)
                    
                except Exception as e:
                    logger.debug(f"Error parsing vulnerability entry: {e}")
                    continue
            
            return findings
            
        except Exception as e:
            logger.error(f"Failed to parse LLM response: {e}")
            return []
    
    def _ast_based_analysis(
        self, 
        file_path: Path, 
        content: str, 
        file_info: Dict[str, Any]
    ) -> List[VulnerabilityFinding]:
        """AST-based analysis for deeper code understanding."""
        findings = []
        
        if file_path.suffix == '.py':
            findings.extend(self._python_ast_analysis(file_path, content))
        elif file_path.suffix in ['.js', '.ts']:
            findings.extend(self._javascript_ast_analysis(file_path, content))
        
        return findings
    
    def _python_ast_analysis(self, file_path: Path, content: str) -> List[VulnerabilityFinding]:
        """Python-specific AST analysis."""
        findings = []
        
        try:
            tree = ast.parse(content)
            
            class VulnerabilityVisitor(ast.NodeVisitor):
                def __init__(self, detector):
                    self.detector = detector
                    self.findings = []
                    self.current_function = None
                
                def visit_FunctionDef(self, node):
                    old_function = self.current_function
                    self.current_function = node.name
                    
                    # Check for admin/sensitive functions without decorators
                    if any(keyword in node.name.lower() for keyword in ['admin', 'delete', 'update', 'create', 'modify']):
                        has_auth = any(dec.id if hasattr(dec, 'id') else str(dec) 
                                      for dec in node.decorator_list 
                                      if 'auth' in str(dec).lower() or 'login' in str(dec).lower())
                        if not has_auth:
                            self.findings.append(VulnerabilityFinding(
                                worker="ast_analyzer",
                                file=str(file_path),
                                line=node.lineno,
                                category="broken_access_control",
                                severity=SeverityLevel.HIGH,
                                confidence=0.8,
                                explanation=f"Function '{node.name}' appears to be administrative but lacks authentication decorator",
                                code_snippet=self.detector._extract_code_snippet(content, node.lineno),
                                references=["https://owasp.org/www-project-top-ten/2021/A01_2021-Broken_Access_Control/"]
                            ))
                    
                    self.generic_visit(node)
                    self.current_function = old_function
                
                def visit_Call(self, node):
                    # Check for dangerous function calls
                    func_name = self._get_func_name(node.func)
                    
                    # SQL injection patterns
                    if func_name in ['execute', 'executemany', 'executescript']:
                        if node.args and self._has_string_formatting(node.args[0]):
                            self.findings.append(VulnerabilityFinding(
                                worker="ast_analyzer",
                                file=str(file_path),
                                line=node.lineno,
                                category="sql_injection",
                                severity=SeverityLevel.CRITICAL,
                                confidence=0.9,
                                explanation="SQL query constructed with string formatting - high risk of SQL injection",
                                code_snippet=self.detector._extract_code_snippet(content, node.lineno),
                                references=["https://cwe.mitre.org/data/definitions/89.html"]
                            ))
                    
                    # Command injection
                    elif func_name in ['system', 'popen', 'call', 'run', 'getoutput', 'getstatusoutput']:
                        if self._has_user_input(node):
                            self.findings.append(VulnerabilityFinding(
                                worker="ast_analyzer",
                                file=str(file_path),
                                line=node.lineno,
                                category="command_injection",
                                severity=SeverityLevel.CRITICAL,
                                confidence=0.85,
                                explanation="System command with potential user input - risk of command injection",
                                code_snippet=self.detector._extract_code_snippet(content, node.lineno),
                                references=["https://cwe.mitre.org/data/definitions/78.html"]
                            ))
                    
                    # Unsafe deserialization
                    elif func_name == 'loads' and hasattr(node.func, 'value') and hasattr(node.func.value, 'id'):
                        if node.func.value.id == 'pickle':
                            self.findings.append(VulnerabilityFinding(
                                worker="ast_analyzer",
                                file=str(file_path),
                                line=node.lineno,
                                category="unsafe_deserialization",
                                severity=SeverityLevel.CRITICAL,
                                confidence=0.95,
                                explanation="Pickle deserialization can execute arbitrary code",
                                code_snippet=self.detector._extract_code_snippet(content, node.lineno),
                                references=["https://cwe.mitre.org/data/definitions/502.html"]
                            ))
                    
                    # eval/exec usage
                    elif func_name in ['eval', 'exec']:
                        self.findings.append(VulnerabilityFinding(
                            worker="ast_analyzer",
                            file=str(file_path),
                            line=node.lineno,
                            category="code_injection",
                            severity=SeverityLevel.CRITICAL,
                            confidence=0.9,
                            explanation=f"Use of {func_name}() can lead to arbitrary code execution",
                            code_snippet=self.detector._extract_code_snippet(content, node.lineno),
                            references=["https://cwe.mitre.org/data/definitions/94.html"]
                        ))
                    
                    self.generic_visit(node)
                
                def _get_func_name(self, func):
                    if hasattr(func, 'id'):
                        return func.id
                    elif hasattr(func, 'attr'):
                        return func.attr
                    return str(func)
                
                def _has_string_formatting(self, node):
                    # Check for %, .format(), or f-string patterns
                    if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Mod):
                        return True
                    if isinstance(node, ast.Call) and hasattr(node.func, 'attr') and node.func.attr == 'format':
                        return True
                    if isinstance(node, ast.JoinedStr):  # f-string
                        return True
                    return False
                
                def _has_user_input(self, node):
                    # Simple heuristic - check for common user input sources
                    for arg in node.args:
                        if isinstance(arg, ast.Name) and any(inp in arg.id.lower() for inp in ['user', 'input', 'request', 'param']):
                            return True
                    return False
            
            visitor = VulnerabilityVisitor(self)
            visitor.visit(tree)
            findings.extend(visitor.findings)
            
        except Exception as e:
            logger.debug(f"AST analysis error for {file_path}: {e}")
        
        return findings
    
    def _analyze_python_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Enhanced Python-specific analysis."""
        findings = []
        lines = content.split('\n')
        
        # Python-specific patterns
        python_patterns = {
            "pickle_deserialization": {
                "regex": r"pickle\.loads?\s*\(",
                "line_check": lambda line: not any(safe in line for safe in ['SafeLoader', 'safe_load']),
                "severity": "critical",
                "confidence": 0.9,
                "description": "Unsafe pickle deserialization can execute arbitrary code"
            },
            "eval_usage": {
                "regex": r"\beval\s*\(",
                "severity": "critical",
                "confidence": 0.85,
                "description": "eval() can execute arbitrary code"
            },
            "exec_usage": {
                "regex": r"\bexec\s*\(",
                "severity": "critical",
                "confidence": 0.85,
                "description": "exec() can execute arbitrary code"
            },
            "assert_usage": {
                "regex": r"\bassert\s+",
                "severity": "low",
                "confidence": 0.6,
                "description": "Assertions can be disabled in production"
            },
            "yaml_unsafe": {
                "regex": r"yaml\.load\s*\([^)]*\)(?!.*Loader\s*=\s*yaml\.SafeLoader)",
                "severity": "high",
                "confidence": 0.8,
                "description": "yaml.load() without SafeLoader can execute arbitrary code"
            },
            "sql_string_format": {
                "regex": r"(?:execute|executemany)\s*\([^)]*%[^)]*\)",
                "severity": "critical",
                "confidence": 0.9,
                "description": "SQL query using string formatting - SQL injection risk"
            },
            "os_system": {
                "regex": r"os\.system\s*\(",
                "severity": "high",
                "confidence": 0.8,
                "description": "os.system() is vulnerable to command injection"
            },
            "subprocess_shell": {
                "regex": r"subprocess\.(?:call|run|Popen)\s*\([^)]*shell\s*=\s*True",
                "severity": "high",
                "confidence": 0.85,
                "description": "subprocess with shell=True is vulnerable to command injection"
            },
            "weak_random": {
                "regex": r"random\.(?:random|randint|choice)\s*\([^)]*\)",
                "context_check": lambda lines, i: any(sec in ' '.join(lines[max(0,i-2):i+3]).lower() for sec in ['token', 'session', 'key', 'password']),
                "severity": "medium",
                "confidence": 0.7,
                "description": "Use of non-cryptographic random for security purposes"
            },
            "hardcoded_secret": {
                "regex": r"(?:password|secret|api_key|token)\s*=\s*['\"][^'\"]{8,}['\"]",
                "line_check": lambda line: not any(placeholder in line.lower() for placeholder in ['example', 'test', 'dummy', 'placeholder']),
                "severity": "critical",
                "confidence": 0.8,
                "description": "Hardcoded credential detected"
            },
            "open_file": {
                "regex": r"open\s*\([^)]*\)",
                "context_check": lambda lines, i: any(inp in lines[i].lower() for inp in ['user', 'input', 'request', 'param']),
                "severity": "high",
                "confidence": 0.7,
                "description": "File operation with potential user input - path traversal risk"
            }
        }
        
        for line_num, line in enumerate(lines, 1):
            for pattern_name, pattern_config in python_patterns.items():
                if re.search(pattern_config["regex"], line):
                    # Apply line-specific check if exists
                    if "line_check" in pattern_config and not pattern_config["line_check"](line):
                        continue
                    
                    # Apply context check if exists
                    if "context_check" in pattern_config and not pattern_config["context_check"](lines, line_num-1):
                        continue
                    
                    finding = VulnerabilityFinding(
                        worker=self.llm_client.model_name if self.llm_client else "python_analyzer",
                        file=str(file_path),
                        line=line_num,
                        category=pattern_name,
                        severity=SeverityLevel(pattern_config["severity"]),
                        confidence=pattern_config["confidence"],
                        explanation=pattern_config["description"],
                        code_snippet=self._extract_code_snippet(content, line_num),
                        references=["https://owasp.org/www-project-top-ten/", "https://cwe.mitre.org/"]
                    )
                    findings.append(finding)
        
        return findings
    
    def _analyze_javascript_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Enhanced JavaScript-specific analysis."""
        findings = []
        lines = content.split('\n')
        
        js_patterns = {
            "dom_xss": {
                "regex": r"\.innerHTML\s*[=\+]+\s*[^;]*(?:request|input|param|query|\$)",
                "severity": "high",
                "confidence": 0.85,
                "description": "DOM-based XSS via innerHTML"
            },
            "eval_usage": {
                "regex": r"\beval\s*\(",
                "severity": "critical",
                "confidence": 0.9,
                "description": "eval() can execute arbitrary code"
            },
            "new_function": {
                "regex": r"new\s+Function\s*\(",
                "severity": "critical",
                "confidence": 0.85,
                "description": "Dynamic function creation can execute arbitrary code"
            },
            "document_write": {
                "regex": r"document\.write\s*\(",
                "severity": "high",
                "confidence": 0.8,
                "description": "document.write() with user input can cause XSS"
            },
            "location_href": {
                "regex": r"(?:window\.)?location(?:\.href)?\s*=\s*[^;]*(?:request|input|param|query)",
                "severity": "high",
                "confidence": 0.75,
                "description": "Open redirect vulnerability"
            },
            "localstorage_sensitive": {
                "regex": r"localStorage\.setItem\s*\([^)]*(?:password|token|session)",
                "severity": "medium",
                "confidence": 0.7,
                "description": "Sensitive data in localStorage"
            },
            "postmessage_origin": {
                "regex": r"addEventListener\s*\(\s*['\"]message['\"].*?(?!.*origin)",
                "severity": "high",
                "confidence": 0.75,
                "description": "postMessage without origin validation"
            },
            "sql_template": {
                "regex": r"(?:SELECT|INSERT|UPDATE|DELETE).*?\$\{",
                "severity": "critical",
                "confidence": 0.85,
                "description": "SQL query with template literals - injection risk"
            },
            "os_command": {
                "regex": r"(?:exec|spawn|execFile)\s*\([^)]*(?:\$\{|\\$|request|params)",
                "severity": "critical",
                "confidence": 0.85,
                "description": "Command execution with user input"
            }
        }
        
        for line_num, line in enumerate(lines, 1):
            for pattern_name, pattern_config in js_patterns.items():
                if re.search(pattern_config["regex"], line):
                    finding = VulnerabilityFinding(
                        worker=self.llm_client.model_name if self.llm_client else "javascript_analyzer",
                        file=str(file_path),
                        line=line_num,
                        category=pattern_name,
                        severity=SeverityLevel(pattern_config["severity"]),
                        confidence=pattern_config["confidence"],
                        explanation=pattern_config["description"],
                        code_snippet=self._extract_code_snippet(content, line_num),
                        references=["https://owasp.org/www-project-top-ten/"]
                    )
                    findings.append(finding)
        
        return findings
    
    def _analyze_dependencies(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Analyze dependencies for known vulnerabilities."""
        findings = []
        
        # Known vulnerable versions (simplified - in production, use a CVE database)
        vulnerable_packages = {
            "express": {"vulnerable": ["<4.17.1"], "cve": "CVE-2019-1010266"},
            "django": {"vulnerable": ["<2.2.10", "<3.0.3"], "cve": "CVE-2020-7471"},
            "flask": {"vulnerable": ["<1.0"], "cve": "CVE-2018-1000656"},
            "jquery": {"vulnerable": ["<3.5.0"], "cve": "CVE-2020-11022"},
            "lodash": {"vulnerable": ["<4.17.19"], "cve": "CVE-2020-8203"},
            "axios": {"vulnerable": ["<0.21.1"], "cve": "CVE-2020-28168"}
        }
        
        # Check different dependency files
        if file_path.name == "requirements.txt":
            # Python dependencies
            for line_num, line in enumerate(content.split('\n'), 1):
                match = re.match(r'^([a-zA-Z0-9\-_]+)==([0-9\.]+)', line)
                if match:
                    package, version = match.groups()
                    if package.lower() in vulnerable_packages:
                        vuln_info = vulnerable_packages[package.lower()]
                        finding = VulnerabilityFinding(
                            worker="dependency_checker",
                            file=str(file_path),
                            line=line_num,
                            category="vulnerable_dependency",
                            severity=SeverityLevel.HIGH,
                            confidence=0.9,
                            explanation=f"Known vulnerable version of {package}: {version} ({vuln_info['cve']})",
                            code_snippet=line,
                            references=[f"https://nvd.nist.gov/vuln/detail/{vuln_info['cve']}"]
                        )
                        findings.append(finding)
        
        elif file_path.name == "package.json":
            # Node.js dependencies
            try:
                import json
                data = json.loads(content)
                for dep_type in ["dependencies", "devDependencies"]:
                    if dep_type in data:
                        for package, version in data[dep_type].items():
                            if package.lower() in vulnerable_packages:
                                finding = VulnerabilityFinding(
                                    worker="dependency_checker",
                                    file=str(file_path),
                                    line=1,
                                    category="vulnerable_dependency",
                                    severity=SeverityLevel.HIGH,
                                    confidence=0.85,
                                    explanation=f"Potentially vulnerable version of {package}: {version}",
                                    code_snippet=f'"{package}": "{version}"',
                                    references=["https://owasp.org/www-project-dependency-check/"]
                                )
                                findings.append(finding)
            except:
                pass
        
        return findings
    
    def _analyze_configuration_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Analyze configuration files for security issues."""
        findings = []
        
        # Check for exposed secrets in config files
        secret_patterns = [
            (r"(?:password|passwd|pwd)\s*[:=]\s*['\"]?[^'\";\n]{8,}", "password"),
            (r"(?:api[_-]?key|apikey)\s*[:=]\s*['\"]?[a-zA-Z0-9_\-]{20,}", "api_key"),
            (r"(?:secret[_-]?key|secret)\s*[:=]\s*['\"]?[a-zA-Z0-9_\-]{16,}", "secret_key"),
            (r"(?:access[_-]?token|token)\s*[:=]\s*['\"]?[a-zA-Z0-9_\-]{20,}", "access_token"),
            (r"(?:private[_-]?key)\s*[:=]\s*['\"]?-----BEGIN", "private_key")
        ]
        
        lines = content.split('\n')
        for line_num, line in enumerate(lines, 1):
            for pattern, secret_type in secret_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    # Check if it's a real secret (not placeholder)
                    if not any(placeholder in line.lower() for placeholder in 
                              ['example', 'placeholder', 'your_', 'changeme', '<', '>']):
                        finding = VulnerabilityFinding(
                            worker="config_analyzer",
                            file=str(file_path),
                            line=line_num,
                            category="hardcoded_secret",
                            severity=SeverityLevel.CRITICAL,
                            confidence=0.8,
                            explanation=f"Exposed {secret_type} in configuration file",
                            code_snippet=line[:50] + "..." if len(line) > 50 else line,
                            references=["https://owasp.org/www-project-top-ten/2021/A07_2021-Identification_and_Authentication_Failures/"]
                        )
                        findings.append(finding)
        
        # Check for insecure settings
        if file_path.suffix in ['.yml', '.yaml']:
            insecure_yaml_patterns = [
                (r"verify[_-]?ssl\s*:\s*false", "SSL verification disabled"),
                (r"debug\s*:\s*true", "Debug mode enabled"),
                (r"allow[_-]?origin\s*:\s*\*", "Overly permissive CORS")
            ]
            
            for line_num, line in enumerate(lines, 1):
                for pattern, issue in insecure_yaml_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        finding = VulnerabilityFinding(
                            worker="config_analyzer",
                            file=str(file_path),
                            line=line_num,
                            category="security_misconfiguration",
                            severity=SeverityLevel.MEDIUM,
                            confidence=0.75,
                            explanation=issue,
                            code_snippet=line,
                            references=["https://owasp.org/www-project-top-ten/2021/A05_2021-Security_Misconfiguration/"]
                        )
                        findings.append(finding)
        
        return findings
    
    def _smart_deduplication(self, findings: List[VulnerabilityFinding]) -> List[VulnerabilityFinding]:
        """Smart deduplication that keeps unique findings."""
        seen = {}
        deduplicated = []
        
        for finding in findings:
            # Create a key for deduplication
            key = (
                finding.file,
                finding.line,
                finding.category,
                # Include first 50 chars of explanation to differentiate similar issues
                finding.explanation[:50] if finding.explanation else ""
            )
            
            if key not in seen:
                seen[key] = finding
                deduplicated.append(finding)
            else:
                # Keep the one with higher confidence
                if finding.confidence > seen[key].confidence:
                    deduplicated.remove(seen[key])
                    deduplicated.append(finding)
                    seen[key] = finding
        
        return deduplicated
    
    def _validate_context(
        self, 
        line: str, 
        lines: List[str], 
        line_num: int, 
        pattern_config: Dict[str, Any],
        file_path: Path
    ) -> bool:
        """Validate the context of a potential vulnerability."""
        # Check if it's in a comment
        if self._is_comment(line, file_path):
            return False
        
        # Check required context
        if "context_required" in pattern_config:
            context_window = 5
            start = max(0, line_num - context_window - 1)
            end = min(len(lines), line_num + context_window)
            context = ' '.join(lines[start:end]).lower()
            
            if not any(req in context for req in pattern_config["context_required"]):
                return False
        
        # Check excluded contexts
        if "exclude_contexts" in pattern_config:
            context_window = 3
            start = max(0, line_num - context_window - 1)
            end = min(len(lines), line_num + context_window)
            context = ' '.join(lines[start:end]).lower()
            
            if any(excl in context for excl in pattern_config["exclude_contexts"]):
                return False
        
        return True
    
    def _is_comment(self, line: str, file_path: Path) -> bool:
        """Check if line is a comment."""
        stripped = line.strip()
        
        # Language-specific comment patterns
        if file_path.suffix in ['.py']:
            return stripped.startswith('#')
        elif file_path.suffix in ['.js', '.ts', '.java', '.c', '.cpp', '.cs', '.go']:
            return stripped.startswith('//') or stripped.startswith('/*')
        elif file_path.suffix in ['.rb']:
            return stripped.startswith('#')
        elif file_path.suffix in ['.php']:
            return stripped.startswith('//') or stripped.startswith('#') or stripped.startswith('/*')
        
        return False
    
    def _calculate_pattern_confidence(
        self,
        line: str,
        lines: List[str],
        line_num: int,
        vuln_type: str,
        pattern_config: Dict[str, Any]
    ) -> float:
        """Calculate confidence based on multiple factors."""
        base_confidence = 0.6
        
        # Increase confidence for certain vulnerability types
        high_confidence_types = ['sql_injection', 'command_injection', 'unsafe_deserialization', 'eval_usage']
        if vuln_type in high_confidence_types:
            base_confidence += 0.2
        
        # Check for obvious indicators
        if vuln_type == "hardcoded_secrets":
            # Real secrets usually have certain characteristics
            value_match = re.search(r'["\']([^"\']+)["\']', line)
            if value_match:
                value = value_match.group(1)
                if len(value) > 20 and any(c.isdigit() for c in value) and any(c.isupper() for c in value):
                    base_confidence += 0.15
        
        # Check surrounding code for mitigating factors
        context_start = max(0, line_num - 3)
        context_end = min(len(lines), line_num + 3)
        context = ' '.join(lines[context_start:context_end]).lower()
        
        # Reduce confidence if there are sanitization functions nearby
        if any(san in context for san in ['sanitize', 'escape', 'validate', 'clean', 'filter']):
            base_confidence -= 0.2
        
        # Reduce confidence if in test code
        if 'test' in str(pattern_config.get('file_path', '')).lower():
            base_confidence -= 0.1
        
        return max(0.3, min(1.0, base_confidence))
    
    def _get_references(self, config: Dict[str, Any]) -> List[str]:
        """Get references for a vulnerability."""
        refs = []
        
        if "owasp" in config:
            refs.append(f"https://owasp.org/www-project-top-ten/2021/{config['owasp']}/")
        
        if "cwe" in config:
            for cwe in config["cwe"]:
                refs.append(f"https://cwe.mitre.org/data/definitions/{cwe.replace('CWE-', '')}.html")
        
        return refs
    
    def _extract_code_snippet(self, content: str, line_number: int, context_lines: int = 3) -> str:
        """Extract code snippet with context."""
        lines = content.split('\n')
        start = max(0, line_number - context_lines - 1)
        end = min(len(lines), line_number + context_lines)
        
        snippet_lines = []
        for i in range(start, end):
            line_num = i + 1
            prefix = ">>> " if line_num == line_number else "    "
            snippet_lines.append(f"{prefix}{line_num:4d}: {lines[i]}")
        
        return '\n'.join(snippet_lines)
    
    # Validation helper methods
    def _check_missing_auth_decorator(self, line: str, match: Any, lines: List[str], line_num: int) -> bool:
        """Check if a route is missing authentication."""
        # Look for the function definition
        for i in range(line_num - 1, min(line_num + 5, len(lines))):
            if re.match(r'^\s*def\s+', lines[i]):
                func_line = lines[i]
                # Check if it's an admin/sensitive function
                if any(keyword in func_line.lower() for keyword in ['admin', 'delete', 'update', 'modify']):
                    # Look for auth decorators above the route
                    for j in range(max(0, line_num - 5), line_num):
                        if any(auth in lines[j] for auth in ['@login_required', '@auth', '@require_']):
                            return False
                    return True
        return False
    
    def _check_weak_rate_limit(self, line: str, match: Any, lines: List[str], line_num: int) -> bool:
        """Check if rate limiting is too weak."""
        try:
            limit = int(match.group(1))
            return limit > 100  # More than 100 requests per time unit is usually too high
        except:
            return False
    
    def _check_weak_password_policy(self, line: str, match: Any, lines: List[str], line_num: int) -> bool:
        """Check for weak password requirements."""
        try:
            length = int(match.group(1))
            return length < 8  # Less than 8 characters is weak
        except:
            return False
    
    def _check_vulnerable_version(self, line: str, match: Any, lines: List[str], line_num: int) -> bool:
        """Check if a dependency version is vulnerable."""
        # In production, this would check against a CVE database
        # For now, just flag very old versions
        package = match.group(1).lower()
        version = match.group(2)
        
        # Simple heuristic - flag if major version is very old
        try:
            major_version = int(version.split('.')[0])
            if package in ['express', 'django', 'flask'] and major_version < 2:
                return True
        except:
            pass
        
        return False
    
    def _check_weak_session_timeout(self, line: str, match: Any, lines: List[str], line_num: int) -> bool:
        """Check for weak session timeout."""
        try:
            timeout = int(match.group(1))
            # Check the time unit
            if 'hour' in line.lower():
                return timeout > 24  # More than 24 hours is too long
            elif 'minute' in line.lower():
                return timeout > 1440  # More than 24 hours in minutes
            elif 'second' in line.lower():
                return timeout > 86400  # More than 24 hours in seconds
        except:
            pass
        return False
    
    def _validate_real_secret(self, line: str, match: Any, lines: List[str], line_num: int) -> bool:
        """Validate if a hardcoded value is a real secret."""
        value_match = re.search(r'["\']([^"\']+)["\']', line)
        if value_match:
            value = value_match.group(1)
            
            # Skip obvious placeholders
            placeholders = ['example', 'placeholder', 'your_', 'xxx', '***', 'test', 'demo', 
                          'dummy', 'sample', 'changeme', 'default', '<', '>', 'todo']
            if any(ph in value.lower() for ph in placeholders):
                return False
            
            # Skip environment variable references
            if value.startswith('$') or value.startswith('process.env') or value.startswith('os.environ'):
                return False
            
            # Real secrets usually have certain characteristics
            if len(value) >= 8:
                has_upper = any(c.isupper() for c in value)
                has_lower = any(c.islower() for c in value)
                has_digit = any(c.isdigit() for c in value)
                
                # If it has good complexity, more likely to be real
                if (has_upper or has_digit) and len(value) >= 12:
                    return True
        
        return False
    
    def _javascript_ast_analysis(self, file_path: Path, content: str) -> List[VulnerabilityFinding]:
        """JavaScript AST-like analysis using regex patterns."""
        findings = []
        lines = content.split('\n')
        
        # Track function context
        current_function = None
        for line_num, line in enumerate(lines, 1):
            # Track function definitions
            func_match = re.match(r'^\s*(?:function\s+(\w+)|const\s+(\w+)\s*=.*?function|\w+\s*:\s*function)', line)
            if func_match:
                current_function = func_match.group(1) or func_match.group(2)
            
            # Check for route handlers without auth
            route_match = re.search(r'app\.(get|post|put|delete|patch)\s*\([\'"]([^\'"\s]+)', line)
            if route_match:
                route_method = route_match.group(1)
                route_path = route_match.group(2)
                
                # Check if it's an admin route
                if any(keyword in route_path.lower() for keyword in ['admin', 'user', 'delete', 'update']):
                    # Look for auth middleware in the same call
                    if not re.search(r'(?:auth|authenticate|requireAuth|isAuthenticated)', line):
                        findings.append(VulnerabilityFinding(
                            worker="js_ast_analyzer",
                            file=str(file_path),
                            line=line_num,
                            category="broken_access_control",
                            severity=SeverityLevel.HIGH,
                            confidence=0.75,
                            explanation=f"Route '{route_path}' appears to handle sensitive operations without authentication middleware",
                            code_snippet=self._extract_code_snippet(content, line_num),
                            references=["https://owasp.org/www-project-top-ten/2021/A01_2021-Broken_Access_Control/"]
                        ))
        
        return findings
    
    # Stub implementations for other language analyzers
    def _analyze_typescript_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return self._analyze_javascript_file(file_path, content, file_info)
    
    def _analyze_java_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement Java-specific patterns
    
    def _analyze_php_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement PHP-specific patterns
    
    def _analyze_c_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement C-specific patterns
    
    def _analyze_cpp_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement C++-specific patterns
    
    def _analyze_go_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement Go-specific patterns
    
    def _analyze_rust_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement Rust-specific patterns
    
    def _analyze_ruby_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement Ruby-specific patterns
    
    def _analyze_csharp_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement C#-specific patterns
    
    def _analyze_swift_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement Swift-specific patterns
    
    def _analyze_kotlin_file(self, file_path: Path, content: str, file_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        return []  # Implement Kotlin-specific patterns

